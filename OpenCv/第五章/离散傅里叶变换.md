# 离散傅里叶变换（DFT）

## 定义

> 离散傅里叶变换（Discrete Fourier Transform，缩写为DFT），是傅里叶变换在时域和频域上都呈离散的形式，将信号的时域采样变换为其DTFT的频域采样。

![傅里叶变换](https://upload-images.jianshu.io/upload_images/9140378-de1fb5f4dcdc6d61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)

> 对于N点序列{X[n]}(0 <= n < = N),它的离散傅里叶变换为:

![show](https://upload-images.jianshu.io/upload_images/9140378-5d1784a6291d137f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)

## dft() 函数

> dft()函数的作用是对一维或者二维的浮点数数组进行正向或反向的离散傅里叶变换。

`函数原型`

```c
void dft(
    InoutArray src,  //输入矩阵
    OutputArray dst, ///输出矩阵
    int flags = 0,  //转换的标识符
    int onozeroRows,  //
)
```

第三个参数，转换的标识符分为:

+ DFT_INVERSE 用一维或二维逆变换代替默认的正向变换。
+ DFT_SCALE 缩放比例标识符，输出的结果都会以1 / N进行缩放。
+ DFT_CMPLEX_OUTPUT、DFT_REAL_OUTPUT 进行一维或二维的数组反变换。

## 返回DFT最优尺寸大小：getOptimalDFTSize()函数

```c
void int getOptimalDFTSize(int vecsize);
```

## 扩充图像边界：copyMakeBorder()函数

```c
void copyMakeBorder(
    InputArray src,  //输入图像
    OutputArray dst,  //输出图像
    int top,  //在图像上方扩充的像素值
    int bottom,  //在图像下方扩充的像素值
    int left,  //在图像左方扩充的像素值
    int right,  //在图像右方扩充的像素值
    int borderType, //边界类型·
    const Scalars,
)
```

## 计算二维矢量的幅值：magnitude()函数

> 用于计算二维矢量的幅值

```c
void magnitude(
    InputArray x,  //表示矢量的浮点型X坐标值,即实部
    InputArray y,  //表示矢量的浮点型Y坐标值，即虚部
    OutputArray magnitude,  //输出的幅值
)
```

## 计算自然对数：log() 函数

> log()函数的功能是计算每个数组元素绝对值的自然对数

```c
void log(
    InputArray src,
    OutputArray dst,
);

原理即为：

if(src(I) != 0)
    log|src(I)|
else
    C
```

## 矩阵归一化：normalize()函数

```c
void normalize(
    InputArray src,
    OutputArray dst,
    double alpha = 1,  //归一化之后的最大值，有默认值1
    double beta = 0,  //归一化之后的最大值，有默认值0
    int norm_type = NORM_L2,  //归一化类型
    int dtype = -1,   为负数时输出矩阵和src有同样的类型，否则，它和src有同样的通道数，深度为CV_MAT_DEPTH
    InputArray mask=noArray(),  可选的操作掩模
)
```

## getOptimalDFTSize函数

> 该函数返回给定向量尺寸的傅里叶最优尺寸大小。为了提高离散傅里叶变换的运行速度，需要扩充图像。

## 使用dft函数计算两个二维实矩阵卷积的示例核心片段

+ 其中MulSpectrums的作用是计算两个傅里叶频谱的每个元素的乘法

```c
void convolveDft(InputArray A, InputArray B, OutputArray C)
{
    //初始化输出矩阵
    C.create(abs(A.rows - B.rows) + 1, abs(A.cols - B.cols) + 1, A.type);

    //计算DFT变换的尺寸
    dftSize.width = getOptimalDFTSize(A.cols + B.cols - 1);
    dftSize.height = getOptimalDFTSize(A.rows + B.rows - 1);

    //分配临时缓冲区并初始化置0
    Mat tempA(dftSize,A.type(),Scalar::all(0));
    Mat tempB(dftSize,B.type(),Scalar::all(0));

    //分别复制A和B到tempA和tempB的左上角
    Mat roiA(tempA,Rect(0,0,A.cols,A.rows));
    A.copyTo(roiA);
    Mat roiB(tempB,Rect(0,0,B.cols,B.rows));
    B.copyTO(roiB);

    //就地操作，进行快速傅里叶变换，并将nonzeroRows 参数置为零，以进行更加快速的处理。
    dft(tempA,tempA,0,A.rows);
    dft(tempB,tempB,0,B.rows);

    //将得到的频谱相乘，结果存放于tempA当中
    mulSpectrums(tempA,tempB,tempA);  

    //将结果变换为频域，尽管结果行（result.rows）都为非零，我们只需其中的C.rows的第一行，所以采用nonzeroRows == C.rows
    dft(tempA,tempA,EFT_INVERSE + EFT_SCALE,C.rows);

    //将结果复制到C当中
    tempA(Rect(0,0,C.cols,C.rows)).copyTo(C);

    //所有的临时缓存区将被自动释放，所以无需收尾操作
}
```