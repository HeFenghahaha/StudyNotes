# Android实验室CV培训

![OpenCV](https://upload-images.jianshu.io/upload_images/9140378-36aac9b3f8ce39e2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 傅里叶变换（空间域 -> 频率域）

### 什么是傅里叶变换？

`维基百科：`

> 傅里叶变换（法语：Transformation de Fourier、英语：Fourier transform）是一种线性积分变换，用于信号在时域（或空域）和频域之间的变换，在物理学和工程学中有许多应用。因其基本思想首先由法国学者约瑟夫·傅里叶系统地提出，所以以其名字来命名以示纪念。实际上傅里叶变换就像化学分析，确定物质的基本成分；信号来自自然界，也可对其进行分析，确定其基本成分。

> 通俗的讲就是可以将任何具有周期性变换的函数分解为诸多个不同频率的三角函数的叠加

![傅里叶变换](https://upload-images.jianshu.io/upload_images/9140378-de1fb5f4dcdc6d61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)

> 从频率的方向观察整个分解的三角函数

![变换结果](https://upload-images.jianshu.io/upload_images/9140378-2a3a371b0e6ec1ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340)


> <font size="4">傅里叶变换在图像处理中有什么作用？</font>

<font size="3">1.图像增强与图像去噪</font>

+ 绝大部分噪音都是图像的高频分量，通过低通滤波器来滤除高频——噪声; 边缘也是图像的高频分量，可以通过添加高频分量来增强原始图像的边缘；

<font size="3">2.图像分割之边缘检测</font>

+ 提取图像高频分量

<font size="3">3.图像特征提取：</font>

+ 形状特征：傅里叶描述
+ 纹理特征：直接通过傅里叶系数来计算纹理特征
+ 其他特征：将提取的特征值进行傅里叶变换来使特征具有平移、伸缩、旋转不变性

<font size="3">4.图像压缩</font>

+ 可以直接通过傅里叶系数来压缩数据；常用的离散余弦变换是傅立叶变换的实变换；

## 垂直边缘检测

<font size="3">图像当中存在有像素的跃变，而边缘检测的目的就是找到这些像素点。</font>

<div align="center">

![H1=_VAZ2I.=png](https://upload-images.jianshu.io/upload_images/9140378-1c8ad332ae92e2a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540) </div>


## 图像滤波

<font size="4">图像滤波，即在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制,即去掉无关的噪音，保留有用的信息</font>

+ <font size="3">平滑 -- 去噪，例如剔除到图像上的一只鸟，根据周围两边的像素值计算一个近似值，换为均值，即对图像积分。
+ 锐化 -- 将噪点变得更强，例如加强一只鸟的显示，将图像边缘的差值变得更大，即对图像进行微分。 </font>

## 滤波常用API

+ <font size="3">边缘检测
+ Sobel，拉普拉斯算子
+ 图像去噪/平滑
+ GaussianBlur</font>

## 中型差分

```c++

#include <opencv2/opencv.hpp>
#include "opencv2/highgui/highgui.hpp"
#include <iostream>
#define WINDOW_NAME "【程序窗口】"

using namespace cv;
using namespace std;

int main(int argc, char **argv)
{
    /*
    VideoCapture video(0);
    while (true)
    {
        Mat frame;//视频的每一帧
        video >> frame;  //将视频写入每一帧
        cvtColor(frame,frame,COLOR_RGB2GRAY);
        cvNamedWindow("frame", WINDOW_AUTOSIZE);
        imshow("frame",frame);

        waitKey(30);
    }
    */

    Mat srcImage = imread("D:\\Desktop\\lena.jpg", 1); //读取图片
    cvtColor(srcImage, srcImage, COLOR_BGR2GRAY);      //转为灰度图像

    namedWindow("srcImage", WINDOW_AUTOSIZE); //新建窗口
    imshow("srcImage", srcImage);             //显示图像
    //waitKey(0);  //图像显示为一帧

    //由于中型差分的原因，输出图像比原始图象少了两列
    Mat dImage = Mat(srcImage.rows, srcImage.cols - 2, CV_8UC1);

    //循环遍历整个图像
    for (int i = 0; i < srcImage.rows; i++)
    {
        for (int j = 1; j < srcImage.cols - 1; j++)
        {
            //对整型数据类型进行运算,进行中型差分
            dImage.at<uchar>(i, j - 1) = srcImage.at<uchar>(i, j + 1) - srcImage.at<uchar>(i, j - 1);
        }
    }
    namedWindow("dImage", WINDOW_AUTOSIZE); //处理后图像窗口
    imshow("dImage", dImage);               //显示处理后的图像

    waitKey(0); //图像显示为一帧
    return 0;
}

```

![HGg](https://upload-images.jianshu.io/upload_images/9140378-60d3f3e6fe60aed6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)

## 高斯模糊

> <font size="4">首先要清楚高斯模糊的原理是什么？</font>

<font size="3">高斯模糊，听起来很高大上，但是其实是一门很基础的算法应用，普遍运用在Android及其他方面，高斯模糊之所以叫做高斯模糊，是因为它运用了概率统计上的正态分布(高斯分布)的密度函数，即：</font>

<div align="center">

![image1.png](https://upload-images.jianshu.io/upload_images/9140378-e3dbe0d36fa9b91d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340)  </div>

<font size="3"></font>

<font size="3">其中u是x的均值，σ是x的标准差，因为每次进行计算的时候都是以当前的点为原点，所以u等于0，即化简为：</font>

<div align="center">

![image2.png](https://upload-images.jianshu.io/upload_images/9140378-2acf0681b663de86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340)  </div>

<font size="3">正态分布的一维方程是一种山型图形，越靠近中间，取值越大，越远离中间，取值越小。</font>

<div align="center">

![image3.png](https://upload-images.jianshu.io/upload_images/9140378-34b2475674d39cfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)  </div>

<font size="3">而高斯模糊的原理就是将图像上各个点的像素值等效于其边缘的像素均值，并且这个均值不只是简单的平均值，而是加权平均值，即将中心点”看作正态分布的原点，其他值按照正态分布的值取权重，相加可得。将加权平均值应用到整个图像，就会产生模糊的效果。显然，二维的正太分布是不合适的，我们要用到的是它的二维方程，即：</font>

<div align="center"> 

![正态分布二维函数](https://upload-images.jianshu.io/upload_images/9140378-506bbf34d3729351.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640) </div>

<font size="3">在二维上的图像：</font>

<div align="center"> 

![正态分布二维](https://upload-images.jianshu.io/upload_images/9140378-662f77f17b7e2738.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640) </div>

<font size="4">假如现在整个图像共有9个像素点,中心点为原点，并且令σ为1(标准正态分布)：</font>

<div align="center"> 

![image7.jpg](https://upload-images.jianshu.io/upload_images/9140378-3e0ddc7eb2a80591.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) </div>

<font size="3">带入高斯公式当中，求出每位上的值：</font>

<div align="center"> 

![image8.jpg](https://upload-images.jianshu.io/upload_images/9140378-c774d3f301931b29.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) </div>

<font size="3">现在这九个像素值加起来等于4.8976，由于加权平均权值和等于1，因此这九个像素值必须都除以4.8976，得：</font>

<div align="center"> 

![image9.jpg](https://upload-images.jianshu.io/upload_images/9140378-103bd44d0d652b3a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/640) </div>

<font size="3">这样图像中的每个像素值都被加权平均化，使得与周围的像素点看起来更加的柔和，从而使得整个图像变得更加模糊。</font>

<font size="3">接着该正态分布的权值放进卷积核当中，然后对整个图像进行卷积。对整个图像进行卷积之后，高斯模糊就算是完成了。</font>

> <font size="4">那"卷积"又是什么？</font>

<font size="3">其实卷积（Convolution）是图像处理中最基本的操作，就是一个二维矩阵A（MN）和一个二维矩阵B（mn）做若干操作，生成一个新的二维矩阵C（M*N），其中m和n远小于M和N，B称为卷积核（kernel），又称滤波器矩阵或模板。</font>

<div align="center"> 

![image10.png](https://upload-images.jianshu.io/upload_images/9140378-1bff7d3bbdb36bc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540) 

![image10.jpg](https://upload-images.jianshu.io/upload_images/9140378-ffbb14cdb3ec6efb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/540)

</div>

<font size="4">而滤波器(卷积核)又分为很多种，一种是均值滤波器，中心原点为0，周围元素值相等，并且和等于1，另一种就是我们现在用的高斯滤波器，高斯滤波器是均值滤波器的高级版本，唯一的区别在于，均值滤波器的卷积核的每个元素都相同，而高斯滤波器的卷积核的元素服从高斯分布。带大家看下其他滤波器。</font>

<font size="4">图像锐化滤波器

<font size="3">即在边缘检测得基础上，将边缘检测得到得像素值再加到原图像上，这样整个图像的边缘显得更加锐化了。也就是在边缘检测得卷积核基础上，中心再加1，再对图像进行卷积。</font>

<div align="center"> 

![Ppng](https://upload-images.jianshu.io/upload_images/9140378-3849de5acc32fc95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640) 
![$~@)U2SB7RW_THDBGHFW4LJ.png](https://upload-images.jianshu.io/upload_images/9140378-f7173d2e36464517.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)</div>


<font size="4">浮雕滤波器</font>

<font size="3">浮雕滤波器浮雕滤波器可以给图像一种3D阴影的效果。只要将中心一边的像素减去另一边的像素就可以了。</font>


<div align="center"> 

![G46LJ5E71VPJI9~F9EU@BKW.png](https://upload-images.jianshu.io/upload_images/9140378-491e86ceec16676b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)

![A8(@png](https://upload-images.jianshu.io/upload_images/9140378-ad64a73383dc02a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640) </div>


> <font size="4">图像的模糊程度取决于什么？</font>


+ 1.<font size="3">取决于σ，也就是x的标准差，σ越大，整个图像的像素值就会变得更加平缓，也就是更模糊，而σ越小，整个图像的像素改变小或者基本不变，这样基本看不到高斯模糊。</font>
+ 2.<font size="3">取决于卷积核的大小，卷积核越大，中心点像素被周围像素(核越大使得这些周围的像素越远)权值化的就更加明显，图像也就更加模糊。</font>

<div align="center"> 

![v2-0f390685117a9510871e3c241ce76d8a_hd.jpg](https://upload-images.jianshu.io/upload_images/9140378-837d353858d1f860.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/440) </div>

### <font size="5">代码</font>

### 导入头文件

```c++
#include <opencv2/opencv.hpp>
#include "opencv2/highgui/highgui.hpp"
#include <iostream>
#define WINDOW_NAME "【程序窗口】"
#define PI 3.1415926

using namespace cv;
using namespace std;

```

### 调用摄像头

```c++
VideoCapture video(0);
while (true)
{
   Mat frame;//视频的每一帧
   video >> frame;  //将视频写入每一帧
   cvtColor(frame,frame,COLOR_RGB2GRAY);
   cvNamedWindow("frame", WINDOW_AUTOSIZE);
   imshow("frame",frame);
   waitKey(30);
}
```

### 高斯模糊 -- 卷积核进行实现

```c++
Mat srcImage = imread("D:\\Desktop\\lena.jpg", 1);  //读取图片
cvtColor(srcImage, srcImage,COLOR_BGR2GRAY);  //转为灰度图像

namedWindow("srcImage", WINDOW_AUTOSIZE);  //新建窗口
imshow("srcImage", srcImage);  //显示图像
//waitKey(0);  //图像显示为一帧

//由于中型差分的原因，输出图像比原始图象少了两列
Mat dImage = Mat(srcImage.rows,srcImage.cols - 2,CV_8UC1);

//循环遍历整个图像
for (int i = 0; i < srcImage.rows; i++)
{
    for (int j = 1; j < srcImage.cols - 1; j++)
    {
        //对整型数据类型进行运算,进行中型差分
        dImage.at<uchar>(i, j - 1) = srcImage.at<uchar>(i, j + 1) - srcImage.at<uchar>(i, j - 1);
    }
}
namedWindow("dImage", WINDOW_AUTOSIZE);  //处理后图像窗口
imshow("dImage", dImage);  //显示处理后的图像

waitKey(0);  //图像显示为一帧

Mat srcImage = imread("D:\\Desktop\\lena.jpg", 1); //读取图片
cvtColor(srcImage, srcImage, COLOR_BGR2GRAY);      //转为灰度图像
namedWindow("srcImage", WINDOW_AUTOSIZE);          //新建窗口
imshow("srcImage", srcImage);                      //显示图像

/*高斯模糊*/

//5×5卷积模板
Mat model = Mat(5, 5, CV_64FC1);
double sigma = 80;  //超参数，根据经验所得
for (int i = - 2; i <= 2 ; i++)  //进行遍历
{
    for (int j = -2; j <= 2; j++)
    {
        //正态分布
        model.at<double>(i + 2, j + 2) =
            exp(-(i * i + j * j) / (2 * sigma * sigma)) /
            (2 * PI * sigma * sigma);
    }
}

//归一化
double gaussSum = 0;
gaussSum = sum(model).val[0];  //卷积核 求和
for (int i = 0; i < model.rows; i++)
{
    for (int j = 0; j < model.cols; j++)
    {
        model.at<double>(i, j) = model.at<double>(i, j) 
            / gaussSum;
    }
}

Mat dst = Mat(srcImage.rows - 4,srcImage.cols - 4,CV_8UC1);

//对整个图片进行遍历卷积
for (int i = 2; i < srcImage.rows - 2; i++)
{
    for (int j = 2; j < srcImage.cols - 2; j++)
    {
        double sum = 0;  //求和目标值
        for (int m = 0; m < model.rows; m++)
        {
            for (int n = 0; n < model.cols; n++)
            {
                sum += (double)srcImage.at<uchar>(i + m - 2, j + n - 2) * 
                    model.at<double>(m,n);  //对整个卷积核进行卷积
            }
        }
        dst.at<uchar>(i - 2, j - 2) = (uchar)sum;  //结果赋值到dst图像当中
    }
}
namedWindow("gaussBlur", WINDOW_AUTOSIZE);
imshow("gaussBlur", dst);
waitKey(0); //图像显示为一帧
```

### 调用高斯模糊库函数  -- 一行代码实现

```c++
Mat dst = srcImage.clone();
//一行代码高斯模糊
GaussianBlur(srcImage, dst, Size(17, 17), 180);
namedWindow("gaussBlur", WINDOW_AUTOSIZE);
imshow("gaussBlur", dst);
waitKey(0); //图像显示为一帧
```

![png](https://upload-images.jianshu.io/upload_images/9140378-cc006a16fd6bf8c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)

## 参考

> <font size="3">[Android图像处理 - 高斯模糊的原理及实现](https://www.jianshu.com/p/4f27069b931b) </br>
[高斯模糊的原理是什么，怎样在界面中实现？](https://www.zhihu.com/question/54918332/answer/142137732) </br>
[高斯模糊与图像卷积滤波一些知识点](https://www.jianshu.com/p/8d2d93c4229b)
