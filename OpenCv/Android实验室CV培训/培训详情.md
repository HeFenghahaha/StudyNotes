# Android实验室CV培训

## 傅里叶变换（空间域 -> 频率域）

### 什么是傅里叶变换？

> 可以将任何具有周期性变换的函数分解为诸多个不同频率的三角函数的叠加

![傅里叶变换](https://upload-images.jianshu.io/upload_images/9140378-de1fb5f4dcdc6d61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)

> 从频率的方向观察整个分解的三角函数

![变换结果](https://upload-images.jianshu.io/upload_images/9140378-2a3a371b0e6ec1ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/340)

### 傅里叶变换在图像处理中有什么作用？

## 图像滤波

## 垂直边缘检测

## 高斯模糊

+ 图像中的每个像素都重新设置像素值为周边相邻像素的平均值。

## 正态分布

## 滤波

+ 平滑 -- 去噪，例如剔除到图像上的一只鸟，根据周围两边的像素值计算一个近似值，换为均值，对应积分。
+ 锐化 -- 将噪点变得更强，例如加强一只鸟的显示，将图像边缘的差值变得更大，对应微分。图像差分

## 滤波常用API

+ 边缘检测
+ Sobel，拉普拉斯算子
+ 图像去噪/平滑
+ GaussianBlur

## 中型差值

```c++

#include <opencv2/opencv.hpp>
#include "opencv2/highgui/highgui.hpp"
#include <iostream>
#define WINDOW_NAME "【程序窗口】"

using namespace cv;
using namespace std;

int main(int argc, char **argv)
{
    /*
    VideoCapture video(0);
    while (true)
    {
        Mat frame;//视频的每一帧
        video >> frame;  //将视频写入每一帧
        cvtColor(frame,frame,COLOR_RGB2GRAY);
        cvNamedWindow("frame", WINDOW_AUTOSIZE);
        imshow("frame",frame);

        waitKey(30);
    }
    */

    Mat srcImage = imread("D:\\Desktop\\lena.jpg", 1); //读取图片
    cvtColor(srcImage, srcImage, COLOR_BGR2GRAY);      //转为灰度图像

    namedWindow("srcImage", WINDOW_AUTOSIZE); //新建窗口
    imshow("srcImage", srcImage);             //显示图像
    //waitKey(0);  //图像显示为一帧

    //由于中型差分的原因，输出图像比原始图象少了两列
    Mat dImage = Mat(srcImage.rows, srcImage.cols - 2, CV_8UC1);

    //循环遍历整个图像
    for (int i = 0; i < srcImage.rows; i++)
    {
        for (int j = 1; j < srcImage.cols - 1; j++)
        {
            //对整型数据类型进行运算,进行中型差分
            dImage.at<uchar>(i, j - 1) = srcImage.at<uchar>(i, j + 1) - srcImage.at<uchar>(i, j - 1);
        }
    }
    namedWindow("dImage", WINDOW_AUTOSIZE); //处理后图像窗口
    imshow("dImage", dImage);               //显示处理后的图像

    waitKey(0); //图像显示为一帧
    return 0;
}

```

![HGg](https://upload-images.jianshu.io/upload_images/9140378-60d3f3e6fe60aed6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)

## 高斯模糊

## 导入头文件

```c++
#include <opencv2/opencv.hpp>
#include "opencv2/highgui/highgui.hpp"
#include <iostream>
#define WINDOW_NAME "【程序窗口】"
#define PI 3.1415926

using namespace cv;
using namespace std;

```

## 调用摄像头

```c++
VideoCapture video(0);
while (true)
{
   Mat frame;//视频的每一帧
   video >> frame;  //将视频写入每一帧
   cvtColor(frame,frame,COLOR_RGB2GRAY);
   cvNamedWindow("frame", WINDOW_AUTOSIZE);
   imshow("frame",frame);
   waitKey(30);
}
```

## 高斯模糊 -- 卷积核进行实现

```c++
Mat srcImage = imread("D:\\Desktop\\lena.jpg", 1);  //读取图片
cvtColor(srcImage, srcImage,COLOR_BGR2GRAY);  //转为灰度图像

namedWindow("srcImage", WINDOW_AUTOSIZE);  //新建窗口
imshow("srcImage", srcImage);  //显示图像
//waitKey(0);  //图像显示为一帧

//由于中型差分的原因，输出图像比原始图象少了两列
Mat dImage = Mat(srcImage.rows,srcImage.cols - 2,CV_8UC1);

//循环遍历整个图像
for (int i = 0; i < srcImage.rows; i++)
{
	for (int j = 1; j < srcImage.cols - 1; j++)
	{
		//对整型数据类型进行运算,进行中型差分
		dImage.at<uchar>(i, j - 1) = srcImage.at<uchar>(i, j + 1) - srcImage.at<uchar>(i, j - 1);
	}
}
namedWindow("dImage", WINDOW_AUTOSIZE);  //处理后图像窗口
imshow("dImage", dImage);  //显示处理后的图像

waitKey(0);  //图像显示为一帧

Mat srcImage = imread("D:\\Desktop\\lena.jpg", 1); //读取图片
cvtColor(srcImage, srcImage, COLOR_BGR2GRAY);      //转为灰度图像
namedWindow("srcImage", WINDOW_AUTOSIZE);          //新建窗口
imshow("srcImage", srcImage);                      //显示图像

/*高斯模糊*/

//5×5卷积模板
Mat model = Mat(5, 5, CV_64FC1);
double sigma = 80;  //超参数，根据经验所得
for (int i = - 2; i <= 2 ; i++)  //进行遍历
{
	for (int j = -2; j <= 2; j++)
	{
		//正态分布
		model.at<double>(i + 2, j + 2) =
			exp(-(i * i + j * j) / (2 * sigma * sigma)) /
			(2 * PI * sigma * sigma);
	}
}

//归一化
double gaussSum = 0;
gaussSum = sum(model).val[0];  //卷积核 求和
for (int i = 0; i < model.rows; i++)
{
	for (int j = 0; j < model.cols; j++)
	{
		model.at<double>(i, j) = model.at<double>(i, j) 
			/ gaussSum;
	}
}

Mat dst = Mat(srcImage.rows - 4,srcImage.cols - 4,CV_8UC1);

//对整个图片进行遍历卷积
for (int i = 2; i < srcImage.rows - 2; i++)
{
	for (int j = 2; j < srcImage.cols - 2; j++)
	{
		double sum = 0;  //求和目标值
		for (int m = 0; m < model.rows; m++)
		{
			for (int n = 0; n < model.cols; n++)
			{
				sum += (double)srcImage.at<uchar>(i + m - 2, j + n - 2) * 
					model.at<double>(m,n);  //对整个卷积核进行卷积
			}
		}
		dst.at<uchar>(i - 2, j - 2) = (uchar)sum;  //结果赋值到dst图像当中
	}
}
namedWindow("gaussBlur", WINDOW_AUTOSIZE);
imshow("gaussBlur", dst);
waitKey(0); //图像显示为一帧
```

## 调用高斯模糊库函数

```c++
Mat dst = srcImage.clone();
//一行代码高斯模糊
GaussianBlur(srcImage, dst, Size(17, 17), 180);
namedWindow("gaussBlur", WINDOW_AUTOSIZE);
imshow("gaussBlur", dst);
waitKey(0); //图像显示为一帧
```

![png](https://upload-images.jianshu.io/upload_images/9140378-cc006a16fd6bf8c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)
